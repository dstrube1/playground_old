<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Memory Allocation</TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<B><FONT SIZE=7><P ALIGN="CENTER">Memory Allocation</P>
</B></FONT><P>&nbsp;</P>
<P>One responsibility of an operating system is to control access to a system's resources.  One such resource is memory (both primary and secondary).  To do this, an operating system must keep track of the memory that has been allocated and/or the memory that has not been allocated.  There are many different techniques for doing this bookkeeping.  One is using a free list.</P>
<B><FONT SIZE=7><P ALIGN="CENTER">Free List</P>
</B></FONT><P>A free list is a linked list where each node in the list designates a maximal (largest possible) contiguous block of memory that has not been allocated.  When an operating system allocates memory, the free list is accessed to find a block of memory.  When memory is deallocated, the free list is modified to reflect the deallocation.  Note that each node on the list after deallocation would still denote a maximal contiguous block.  There are many different allocation algorithms but the deallocation algorithm would be independent of the method of allocation.</P>
<B><FONT SIZE=7><P ALIGN="CENTER">Memory Allocation Algorithms</P>
</B></FONT><P>Four of the more popular algorithms are</P>

<UL>
<LI>First fit - memory allocated from first block encountered that is large enough</LI>
<LI>Best fit - memory allocated from block of memory that is closest to the requested size</LI>
<LI>Worst fit - memory allocated from largest block of available memory</LI>
<LI>Random fit - memory allocated from a randomly selected block of sufficient size</LI></UL>

<P>Each of these algorithms has its advantages and disadvantages.  An ideal situation would be for the operating system to monitor the free memory status and to dynamically select the best allocation strategy.  This would require the ability to change algorithm selection on the fly.  The strategy pattern is one way to accomplish this.</P>
<B><FONT SIZE=7><P ALIGN="CENTER">Strategy Pattern</P>
</B></FONT><P>The strategy pattern has an abstract class that contains the specification of the algorithm and concrete subclasses where each concrete subclass contains a potential implementation.  The client just needs to dynamically select the appropriate subclass.</P><IMG SRC="Image4.gif" WIDTH=539 HEIGHT=186 ALIGN="LEFT" HSPACE=12>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<B><FONT SIZE=7><P ALIGN="CENTER">Class Diagram</P>
</B></FONT><P><IMG SRC="Image5.gif" WIDTH=698 HEIGHT=526></P></BODY>
</HTML>
